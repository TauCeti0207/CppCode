<div id="article_content" class="article_content clearfix">
        <link rel="stylesheet" href="https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/ck_htmledit_views-6e43165c0a.css">
                <div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p>
<div class="toc">
 <h3><a name="t0"></a>Linux进程控制</h3>
 <ul><li><a href="#_1" target="_self">进程创建</a></li><li><ul><li><a href="#fork_3" target="_self">fork函数初识</a></li><li><ul><li><a href="#fork_48" target="_self">fork函数返回值</a></li><li><a href="#_63" target="_self">写时拷贝</a></li><li><a href="#fork_75" target="_self">fork常规用法</a></li><li><a href="#fork_80" target="_self">fork调用失败的原因</a></li></ul>
  </li></ul>
  </li><li><a href="#_93" target="_self">进程终止</a></li><li><ul><li><a href="#_95" target="_self">进程退出场景</a></li><li><a href="#_103" target="_self">进程常见退出方法</a></li><li><ul><li><a href="#_exit_127" target="_self">_exit函数</a></li><li><a href="#exit_133" target="_self">exit函数</a></li></ul>
  </li></ul>
  </li><li><a href="#_159" target="_self">进程等待</a></li><li><ul><li><a href="#_161" target="_self">进程等待必要性</a></li><li><a href="#_168" target="_self">进程等待的方法</a></li><li><ul><li><a href="#wait_170" target="_self">wait方法</a></li><li><a href="#waitpid_210" target="_self">waitpid方法（系统调用）</a></li><li><ul><li><a href="#status_236" target="_self">获取子进程status</a></li><li><a href="#_289" target="_self">区分阻塞等待和非阻塞等待</a></li></ul>
   </li></ul>
  </li></ul>
  </li><li><a href="#_366" target="_self">进程程序替换</a></li><li><ul><li><a href="#or_368" target="_self">定义和原理（是什么or为什么）</a></li><li><ul><li><a href="#_370" target="_self">是什么</a></li><li><a href="#_374" target="_self">为什么</a></li></ul>
   </li><li><a href="#_396" target="_self">相关函数及使用（怎么办）</a></li><li><ul><li><a href="#_398" target="_self">函数总览</a></li><li><a href="#_406" target="_self">具体函数使用</a></li><li><ul><li><a href="#execl_408" target="_self">execl</a></li><li><a href="#execv_450" target="_self">execv</a></li><li><a href="#execlp_468" target="_self">execlp</a></li><li><a href="#execvp_516" target="_self">execvp</a></li><li><a href="#execle_526" target="_self">execle</a></li><li><a href="#execve_599" target="_self">execve</a></li><li><a href="#execvpe_605" target="_self">execvpe</a></li><li><a href="#_611" target="_self">总结</a></li></ul>
   </li></ul>
  </li></ul>
  </li><li><a href="#Shell_634" target="_self">简易Shell</a></li></ul>
</div>
<p></p> 
<h1><a name="t1"></a><a id="_1"></a>进程创建</h1> 
<h2><a name="t2"></a><a id="fork_3"></a>fork函数初识</h2> 
<p>在linux中fork函数时非常重要的函数，它从已存在进程中创建一个新进程。新进程为子进程，而原进程为父进程。</p> 
<pre data-index="0" class="prettyprint"><code class="has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;">#include &lt;unistd.h&gt;
pid_t fork(void);
返回值：自进程中返回0，父进程返回子进程id，出错返回-1
<div class="hljs-button {2}" data-title="复制"></div></code><ul class="pre-numbering" style=""><li style="color: rgb(153, 153, 153);">1</li><li style="color: rgb(153, 153, 153);">2</li><li style="color: rgb(153, 153, 153);">3</li></ul></pre> 
<p>进程调用fork，当控制转移到内核中的fork代码后，内核做：</p> 
<blockquote> 
 <ul><li>分配新的内存块和内核数据结构给子进程</li><li>将父进程部分数据结构内容拷贝至子进程</li><li>添加子进程到系统进程列表当中</li><li>fork返回，开始调度器调度</li></ul> 
</blockquote> 
<p><img src="https://img-blog.csdnimg.cn/img_convert/0f0a69467606aec031b82d8ae6f87869.png" alt="image-20220819100623488"></p> 
<p>当一个进程调用fork之后，就有两个二进制代码相同的进程。而且它们都运行到相同的地方。但每个进程都将可以 开始它们自己的旅程，看如下程序。</p> 
<pre data-index="1" class="prettyprint"><code class="has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;">int main( void )
{
	pid_t pid;
	printf("Before: pid is %d\n", getpid());
	if ( (pid=fork()) == -1 )
		perror("fork()"),exit(1);
	printf("After:pid is %d, fork return %d\n", getpid(), pid);
	sleep(1);
	return 0;
} 
运行结果：
[root@localhost linux]# ./a.out
Before: pid is 43676
After:pid is 43676, fork return 43677
After:pid is 43677, fork return 0
<div class="hljs-button {2}" data-title="复制"></div></code><ul class="pre-numbering" style=""><li style="color: rgb(153, 153, 153);">1</li><li style="color: rgb(153, 153, 153);">2</li><li style="color: rgb(153, 153, 153);">3</li><li style="color: rgb(153, 153, 153);">4</li><li style="color: rgb(153, 153, 153);">5</li><li style="color: rgb(153, 153, 153);">6</li><li style="color: rgb(153, 153, 153);">7</li><li style="color: rgb(153, 153, 153);">8</li><li style="color: rgb(153, 153, 153);">9</li><li style="color: rgb(153, 153, 153);">10</li><li style="color: rgb(153, 153, 153);">11</li><li style="color: rgb(153, 153, 153);">12</li><li style="color: rgb(153, 153, 153);">13</li><li style="color: rgb(153, 153, 153);">14</li><li style="color: rgb(153, 153, 153);">15</li></ul></pre> 
<p>这里看到了三行输出，一行before，两行after。进程43676先打印before消息，然后它有打印after。另一个after 消息有43677打印的。注意到进程43677没有打印before，为什么呢？如下图所示</p> 
<p><img src="https://img-blog.csdnimg.cn/img_convert/ac23a9b820194e5d6d93f5943b4afcd0.png" alt="image-20220819102649966"></p> 
<p>所以，fork之前父进程独立执行，fork之后，父子两个执行流分别执行。注意，fork之后，谁先执行完全由调度器决定。</p> 
<h3><a name="t3"></a><a id="fork_48"></a>fork函数返回值</h3> 
<blockquote> 
 <ul><li>子进程返回0</li><li>父进程返回的是子进程的pid。</li></ul> 
</blockquote> 
<blockquote> 
 <p>问：fork()之后，是否只有fork之后的代码是被父子进程共享的？</p> 
 <p>答：一般情况下，fork()之后，父子共享所有的代码。</p> 
 <p>注意：子进程执行的代码！=共享的所有代码，只不过子进程只能从这里开始执行（eip程序计数器保存当前正在执行指令的下一条指令，在fork()函数执行的时候，eip作为父进程的上下文数据会被拷贝给子进程，所以子进程和父进程都是从fork()位置后开始执行）。</p> 
 <p>问：fork()之后，操作系统做了什么？</p> 
 <p>答：进程 = 内核的数据结构 + 进程的代码和数据。fork()之后，创建了子进程的内核数据结构（struct task_struct + struct mm_struct + 页表）+ 代码继承父进程，数据以写时拷贝的方式，来进程共享。</p> 
</blockquote> 
<h3><a name="t4"></a><a id="_63"></a>写时拷贝</h3> 
<p>通常，父子代码共享，父子再不写入时，数据也是共享的，当任意一方试图写入，便以写时拷贝的方式各自一份副 本。具体见下图:</p> 
<p><img src="https://img-blog.csdnimg.cn/img_convert/44ecd07bfa52162426b23aa2933c1524.png" alt="image-20220818192640546"></p> 
<p><img src="https://img-blog.csdnimg.cn/img_convert/a7156b19875b1308a238d6f099bd9365.png" alt="image-20220915183318899"></p> 
<blockquote> 
 <p>问：为什么要写时拷贝？创建子进程的时候，就把数据分开，不行吗？</p> 
 <p>答：1. 父进程的数据，子进程不一定全用，即便全用，也不一定全部写入，如果创建子进程的时候，就把数据分开，就会存在浪费空间的现象。2. 最理想的情况就是，只有被子进程修改的数据，进行分离拷贝，不需要修改的共享即可，但是从技术上来讲很难实现。3. 如果fork的时候，就无脑拷贝数据给子进程，会增加fork()的成本（内存和时间）。最终就是为了提高内存的使用效率。</p> 
</blockquote> 
<h3><a name="t5"></a><a id="fork_75"></a>fork常规用法</h3> 
<blockquote> 
 <ul><li>一个父进程希望复制自己，使父子进程同时执行不同的代码段。例如，父进程等待客户端请求，生成子进程来处理请求。</li><li>一个进程要执行一个不同的程序。例如子进程从fork返回后，调用exec函数。</li></ul> 
</blockquote> 
<h3><a name="t6"></a><a id="fork_80"></a>fork调用失败的原因</h3> 
<blockquote> 
 <ul><li>系统中有太多的进程（内存资源有限）</li><li>实际用户的进程数超过了限制（Linux中一般规定每一个用户运行的进程是有限的）</li></ul> 
</blockquote> 
<p>代码测试：</p> 
<p><img src="https://img-blog.csdnimg.cn/img_convert/3175664c2d605e3c4d45c677f17dbde5.png" alt="image-20220819144727485"></p> 
<p>运行结果：</p> 
<p><img src="https://img-blog.csdnimg.cn/img_convert/93bc90e7ad689e791a08a02ad503f96e.png" alt="image-20220819144751117"></p> 
<h1><a name="t7"></a><a id="_93"></a>进程终止</h1> 
<h2><a name="t8"></a><a id="_95"></a>进程退出场景</h2> 
<blockquote> 
 <ul><li>代码运行完毕，结果正确（return 0）</li><li>代码运行完毕，结果不正确（return 0）</li><li>代码异常终止（返回值为非0，表示异常的原因）</li></ul> 
</blockquote> 
<p>注意：return X，X即进程退出码，表征进程退出的信息，要被父进程读取。</p> 
<h2><a name="t9"></a><a id="_103"></a>进程常见退出方法</h2> 
<p>正常终止（可以通过 <code>echo $?</code> 查看进程退出码）：</p> 
<p><code>$?</code>表示在bash中，最近一次进程执行完毕时，对应的进程的退出码。</p> 
<p>使用举例：</p> 
<p><img src="https://img-blog.csdnimg.cn/img_convert/3175664c2d605e3c4d45c677f17dbde5.png" alt="image-20220819150228801"></p> 
<p><img src="https://img-blog.csdnimg.cn/img_convert/d129d5dd0ee0014ca63921708b0bbd85.png" alt="image-20220819150210883"></p> 
<p><img src="https://img-blog.csdnimg.cn/img_convert/5f90fc561ec256504aefb3855fbacc53.png" alt="image-20220819150539411"></p> 
<p>注意：此时进程退出码为0的原因是因为最近一次执行的进程是<code>ls</code>指令所对应的进程，且成功执行，所以进程退出码为0。</p> 
<blockquote> 
 <ol><li>从main返回（return）</li><li>调用exit()（任意位置处）</li><li>_exit</li></ol> 
</blockquote> 
<p>异常退出：</p> 
<blockquote> 
 <ul><li>ctrl + c，信号终止</li></ul> 
</blockquote> 
<h3><a name="t10"></a><a id="_exit_127"></a>_exit函数</h3> 
<p><img src="https://img-blog.csdnimg.cn/img_convert/95f3af084c3e4e3d943cd5c96ab95cdc.png" alt="image-20220819174248018"></p> 
<p><mark>说明：虽然status是int，但是仅有低8位可以被父进程所用。所以_exit(-1)时，在终端执行$?发现返回值 是255</mark>。</p> 
<h3><a name="t11"></a><a id="exit_133"></a>exit函数</h3> 
<p>exit最后也会调用exit, 但在调用exit之前，还做了其他工作：</p> 
<blockquote> 
 <ol><li>执行用户通过atexit或on_exit定义的清理函数。</li><li>关闭所有打开的流，所有的缓存数据均被写入</li><li>调用_exit</li></ol> 
</blockquote> 
<p><img src="https://img-blog.csdnimg.cn/img_convert/653305338763793d2651f38bcca2e9cf.png" alt="image-20220819175143613"></p> 
<p>对比执行：</p> 
<p>代码：</p> 
<p><img src="https://img-blog.csdnimg.cn/img_convert/390327c2b563fa0f0cbb99b15de49684.png" alt="image-20220819180530147"></p> 
<p>执行结果：</p> 
<p><img src="https://img-blog.csdnimg.cn/img_convert/65d22b23d9e6fb814463462fac439e8b.png" alt="image-20220819180456678"></p> 
<p>代码：<img src="https://img-blog.csdnimg.cn/img_convert/bd058d1f2f7f3361a9e8a989302102bc.png" alt="image-20220819180638458"></p> 
<p>执行结果：</p> 
<p><img src="https://img-blog.csdnimg.cn/img_convert/4e8b9f69e1d8e2419b85eaee7a23ad36.png" alt="image-20220819180609819"></p> 
<h1><a name="t12"></a><a id="_159"></a>进程等待</h1> 
<h2><a name="t13"></a><a id="_161"></a>进程等待必要性</h2> 
<blockquote> 
 <ul><li>子进程退出，父进程如果不管不顾，就可能造成‘僵尸进程’的问题，进而造成内存泄漏。</li><li>另外，进程一旦变成僵尸状态，那就刀枪不入，“杀人不眨眼”的kill -9 也无能为力，因为谁也没有办法 杀死一个已经死去的进程。</li><li>最后，父进程派给子进程的任务完成的如何，我们需要知道。如，子进程运行完成，结果对还是不对， 或者是否正常退出。</li><li>父进程通过进程等待的方式，回收子进程资源，获取子进程退出信息</li></ul> 
</blockquote> 
<h2><a name="t14"></a><a id="_168"></a>进程等待的方法</h2> 
<h3><a name="t15"></a><a id="wait_170"></a>wait方法</h3> 
<p><img src="https://img-blog.csdnimg.cn/img_convert/38f8d607e5b3bf560ee1044dce2a0709.png" alt="image-20220819184157600"></p> 
<pre data-index="2" class="prettyprint"><code class="has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;">#include&lt;sys/types.h&gt;
#include&lt;sys/wait.h&gt;
pid_t wait(int*status);
返回值：
	成功返回被等待进程pid，失败返回-1。
参数：
	输出型参数，获取子进程退出状态,不关心则可以设置成为NULL
<div class="hljs-button {2}" data-title="复制"></div></code><ul class="pre-numbering" style=""><li style="color: rgb(153, 153, 153);">1</li><li style="color: rgb(153, 153, 153);">2</li><li style="color: rgb(153, 153, 153);">3</li><li style="color: rgb(153, 153, 153);">4</li><li style="color: rgb(153, 153, 153);">5</li><li style="color: rgb(153, 153, 153);">6</li><li style="color: rgb(153, 153, 153);">7</li></ul></pre> 
<p>使用举例：</p> 
<p>注意：检测进程运行状态的脚本：</p> 
<pre data-index="3" class="prettyprint"><code class="has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;">while :; do ps ajx | grep proc | grep -v grep; sleep 1; echo "--------------------------------"; done
<div class="hljs-button {2}" data-title="复制"></div></code><ul class="pre-numbering" style=""><li style="color: rgb(153, 153, 153);">1</li></ul></pre> 
<p>代码：</p> 
<p><img src="https://img-blog.csdnimg.cn/img_convert/e69ff96217f0f5390e647419d6e7b820.png" alt="image-20220819215317719"></p> 
<p>运行截图：</p> 
<p>刚开始运行：</p> 
<p><img src="https://img-blog.csdnimg.cn/img_convert/6780f57db22097cab3cdb7d69130f8e3.png" alt="image-20220819215047534"></p> 
<p>使用<code>kill</code>命令杀死子进程后，但是父进程并未受到子进程的返回的PID，所以变成了僵尸状态的进程：</p> 
<p><img src="https://img-blog.csdnimg.cn/img_convert/18dab85e19ca5eea9556161655f4841d.png" alt="image-20220819215126504"></p> 
<p>当父进程等待子进程后，子进程被回收：</p> 
<p><img src="https://img-blog.csdnimg.cn/img_convert/fbde22ddb1edfd578d9ac3b1eff3da3b.png" alt="image-20220819215238911"></p> 
<h3><a name="t16"></a><a id="waitpid_210"></a>waitpid方法（系统调用）</h3> 
<p><img src="https://img-blog.csdnimg.cn/img_convert/01492c0d67db9141b349f641cdf97e73.png" alt="image-20220819220717803"></p> 
<pre data-index="4" class="prettyprint"><code class="has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;">pid_ t waitpid(pid_t pid, int *status, int options);
返回值：
	当正常返回的时候waitpid返回收集到的子进程的进程ID；
	如果设置了选项WNOHANG,而调用中waitpid发现没有已退出的子进程可收集,则返回0；
	如果调用中出错,则返回-1,这时errno会被设置成相应的值以指示错误所在；
参数：
	pid：
		Pid=-1,等待任一个子进程。与wait等效。
		Pid&gt;0.等待其进程ID与pid相等的子进程。
	status（输出型参数：通过调用该函数，从函数内部拿出特定的）:
		WIFEXITED(status): 若为正常终止子进程返回的状态，则为真。（查看进程是否是正常退出）
		WEXITSTATUS(status): 若WIFEXITED非零，提取子进程退出码。（查看进程的退出码）
	options:
		WNOHANG: 若pid指定的子进程没有结束，则waitpid()函数返回0，不予以等待。若正常结束，则返回该子进
程的ID。阻塞等待是0（等待的一方处于等待状态，注意不是被等待的一方）。
<div class="hljs-button {2}" data-title="复制"></div></code><ul class="pre-numbering" style=""><li style="color: rgb(153, 153, 153);">1</li><li style="color: rgb(153, 153, 153);">2</li><li style="color: rgb(153, 153, 153);">3</li><li style="color: rgb(153, 153, 153);">4</li><li style="color: rgb(153, 153, 153);">5</li><li style="color: rgb(153, 153, 153);">6</li><li style="color: rgb(153, 153, 153);">7</li><li style="color: rgb(153, 153, 153);">8</li><li style="color: rgb(153, 153, 153);">9</li><li style="color: rgb(153, 153, 153);">10</li><li style="color: rgb(153, 153, 153);">11</li><li style="color: rgb(153, 153, 153);">12</li><li style="color: rgb(153, 153, 153);">13</li><li style="color: rgb(153, 153, 153);">14</li><li style="color: rgb(153, 153, 153);">15</li></ul></pre> 
<blockquote> 
 <ul><li>如果子进程已经退出，调用wait/waitpid时，wait/waitpid会立即返回，并且释放资源，获得子进程退出信息（从子进程的task_struct中获得退出码）。</li><li>如果在任意时刻调用wait/waitpid，子进程存在且正常运行，则进程可能阻塞。</li><li>如果不存在该子进程，则立即出错返回。</li></ul> 
</blockquote> 
<h4><a id="status_236"></a>获取子进程status</h4> 
<blockquote> 
 <ul><li>wait和waitpid，都有一个status参数，该参数是一个输出型参数，由操作系统填充。</li><li>如果传递NULL，表示不关心子进程的退出状态信息。</li><li>否则，操作系统会根据该参数，将子进程的退出信息反馈给父进程。</li><li>status不能简单的当作整形来看待，可以当作位图来看待，具体细节如下图（只研究status低16比特 位）：</li></ul> 
</blockquote> 
<p><img src="https://img-blog.csdnimg.cn/img_convert/291c8fcd92349dbbdf23cb5bbad2d0fe.png" alt="image-20220820150058754"></p> 
<p>0~7：表示处理异常情况（代码跑完和代码异常退出的两种情况）</p> 
<p>8~15：保存退出码（代码跑完，结果对还是代码跑完结果不对这两种情况）</p> 
<p>终止信号（低7位）：进程退出时受到的信号。进程退出，如果异常退出，是因为这个进程受到了特定的信号。</p> 
<blockquote> 
 <p><strong>注意：使用<code>kill -l</code>命令可以查看所有终止信号</strong>：</p> 
 <p><img src="https://img-blog.csdnimg.cn/img_convert/0e9074eae2b2e022a89585e63a7b2509.png" alt="image-20220820154921050"></p> 
 <p><mark>注意：没有0号信号</mark>。</p> 
</blockquote> 
<p>使用举例：</p> 
<p>代码：</p> 
<p><img src="https://img-blog.csdnimg.cn/img_convert/1270dfd21e528c8a3f57fb25cc77345f.png" alt="image-20220820151438085"></p> 
<p>执行结果：</p> 
<p><img src="https://img-blog.csdnimg.cn/img_convert/247d9e266a18785549ac65850ce37841.png" alt="image-20220820151500409"></p> 
<p>代码：</p> 
<p>执行结果：</p> 
<p>程序刚开始执行：</p> 
<p><img src="https://img-blog.csdnimg.cn/img_convert/9f0a0ccb2e87ca116975154f5bffb82e.png" alt="image-20220820155301620"></p> 
<p>执行<code>kill -9 子进程PID</code>后：</p> 
<p><img src="https://img-blog.csdnimg.cn/img_convert/df2a3bbee330d5c519ab8f25886ebf3b.png" alt="image-20220820155416874"></p> 
<blockquote> 
 <p>问：是否可以通过一个全局变量来保存子进程的退出码然后父进程访问呢？</p> 
 <p>答：不可以，因为进程具有独立性，且子进程的数据具有写时拷贝的特性。</p> 
 <p>问：我们先看退出码还是退出信号？</p> 
 <p>答：先看退出信号，确定程序是否正常结束，如果正常结束，再看退出码，查看程序出现的问题；如果异常终止，就没必要再看退出码了，此时的退出码毫无意义，即使退出码此时为0。</p> 
</blockquote> 
<h4><a id="_289"></a>区分阻塞等待和非阻塞等待</h4> 
<p><img src="https://img-blog.csdnimg.cn/img_convert/18a3d5c8cbc54f90b214b47461a6710a.png" alt="image-20220924163406704"></p> 
<p><strong>阻塞等待</strong></p> 
<p>当我们调用某些函数的时候，因为条件不就绪，需要我们阻塞等待，本质：就是当前进程自己变成阻塞状态等条件（可能是任意的软硬件）就绪的时候。再被唤醒。</p> 
<p>举例：之前的都是阻塞等待，此处不再举例。</p> 
<p><strong>非阻塞等待</strong></p> 
<p>当我们调用某些函数的时候，条件并没有就绪，此时调用函数立即返回，并且此时可以继续做一些其它的任务，同时可以采用轮询的方式对条件是否满足进行询问，当条件满足的时候调用函数。</p> 
<pre data-index="5" class="set-code-hide prettyprint"><code class="prism language-cpp has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;">  <span class="token number">1</span> #include<span class="token operator">&lt;</span>stdio<span class="token punctuation">.</span>h<span class="token operator">&gt;</span>                                                                              
  <span class="token number">2</span> #include<span class="token operator">&lt;</span>unistd<span class="token punctuation">.</span>h<span class="token operator">&gt;</span>
  <span class="token number">3</span> #include<span class="token operator">&lt;</span>stdlib<span class="token punctuation">.</span>h<span class="token operator">&gt;</span>
  <span class="token number">4</span> #include<span class="token operator">&lt;</span>sys<span class="token operator">/</span>types<span class="token punctuation">.</span>h<span class="token operator">&gt;</span>
  <span class="token number">5</span> #include<span class="token operator">&lt;</span>sys<span class="token operator">/</span>wait<span class="token punctuation">.</span>h<span class="token operator">&gt;</span>
  <span class="token number">6</span> <span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token number">7</span> <span class="token punctuation">{<!-- --></span>
  <span class="token number">8</span>   pid_t id <span class="token operator">=</span> <span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token number">9</span>   <span class="token keyword">if</span><span class="token punctuation">(</span>id <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
 <span class="token number">10</span>   <span class="token punctuation">{<!-- --></span>
 <span class="token number">11</span>     <span class="token comment">//子进程</span>
 <span class="token number">12</span>     <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
 <span class="token number">13</span>     <span class="token punctuation">{<!-- --></span>
 <span class="token number">14</span>       <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"我是子进程，我的pid:%d,我的ppid:%d\n"</span><span class="token punctuation">,</span> <span class="token function">getpid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">getppid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token number">15</span>       <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token number">16</span>     <span class="token punctuation">}</span>
 <span class="token number">17</span>     <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1004</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token number">18</span>   <span class="token punctuation">}</span>
 <span class="token number">19</span>   <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>id <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
 <span class="token number">20</span>   <span class="token punctuation">{<!-- --></span>
 <span class="token number">21</span>     <span class="token comment">//父进程</span>
 <span class="token number">22</span>     <span class="token comment">//printf("我是父进程，我的pid:%d,我的ppid:%d\n", getpid(), getppid());</span>
 <span class="token number">23</span>     <span class="token comment">//int status = 0;</span>
 <span class="token number">24</span>     <span class="token comment">//pid_t ret = waitpid(-1, &amp;status, 0 );</span>
 <span class="token number">25</span>     <span class="token comment">//if(ret &gt;0)</span>
 <span class="token number">26</span>     <span class="token comment">//{<!-- --></span>
 <span class="token number">27</span>     <span class="token comment">//  printf("等待成功!%d, exit sig:%d,exit code:%d\n", ret, status&amp;0x7F, (status&gt;&gt;8)&amp;0xFF);</span>
 <span class="token number">28</span>     <span class="token comment">//}</span>
 <span class="token number">29</span>     <span class="token keyword">int</span> status <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
 <span class="token number">30</span>     <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
 <span class="token number">31</span>     <span class="token punctuation">{<!-- --></span>
 <span class="token number">32</span>       pid_t ret  <span class="token operator">=</span> <span class="token function">waitpid</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>status<span class="token punctuation">,</span> WNOHANG<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//基于非阻塞的轮询等待方案：WNOHANG</span>
 <span class="token number">33</span>       <span class="token keyword">if</span><span class="token punctuation">(</span>ret <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
 <span class="token number">34</span>       <span class="token punctuation">{<!-- --></span> 
 <span class="token number">35</span>         <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"等待成功!%d, exit sig:%d,exit code:%d\n"</span><span class="token punctuation">,</span> ret<span class="token punctuation">,</span> status<span class="token operator">&amp;</span><span class="token number">0x7F</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>status<span class="token operator">&gt;&gt;</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token operator">&amp;</span><span class="token number">0xFF</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token number">36</span>         <span class="token keyword">break</span><span class="token punctuation">;</span>
 <span class="token number">37</span>       <span class="token punctuation">}</span>
 <span class="token number">38</span>       <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>ret <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
 <span class="token number">39</span>       <span class="token punctuation">{<!-- --></span>
 <span class="token number">40</span>         <span class="token comment">//等待成功了，但是子进程没有退出</span>
 <span class="token number">41</span>         <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"子进程未准备好，父进程做其他事情...\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token number">42</span>         <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token number">43</span>       <span class="token punctuation">}</span>
 <span class="token number">44</span>       <span class="token keyword">else</span> 
 <span class="token number">45</span>       <span class="token punctuation">{<!-- --></span>
 <span class="token number">46</span>         <span class="token comment">//出错了</span>
 <span class="token number">47</span>       <span class="token punctuation">}</span>
 <span class="token number">48</span>     <span class="token punctuation">}</span>
 <span class="token number">49</span>   <span class="token punctuation">}</span>
 <span class="token number">50</span>   <span class="token keyword">else</span> 
 <span class="token number">51</span>   <span class="token punctuation">{<!-- --></span>
 <span class="token number">52</span>     <span class="token comment">//错误情况</span>
 <span class="token number">53</span>   <span class="token punctuation">}</span>
 <span class="token number">54</span> 
 <span class="token number">55</span>   <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
 <span class="token number">56</span> <span class="token punctuation">}</span>              
<div class="hljs-button {2}" data-title="复制"></div></code><div class="hide-preCode-box"><span class="hide-preCode-bt" data-report-view="{&quot;spm&quot;:&quot;1001.2101.3001.7365&quot;}"><img class="look-more-preCode contentImg-no-view" src="https://csdnimg.cn/release/blogv2/dist/pc/img/newCodeMoreWhite.png" alt="" title=""></span></div><ul class="pre-numbering" style=""><li style="color: rgb(153, 153, 153);">1</li><li style="color: rgb(153, 153, 153);">2</li><li style="color: rgb(153, 153, 153);">3</li><li style="color: rgb(153, 153, 153);">4</li><li style="color: rgb(153, 153, 153);">5</li><li style="color: rgb(153, 153, 153);">6</li><li style="color: rgb(153, 153, 153);">7</li><li style="color: rgb(153, 153, 153);">8</li><li style="color: rgb(153, 153, 153);">9</li><li style="color: rgb(153, 153, 153);">10</li><li style="color: rgb(153, 153, 153);">11</li><li style="color: rgb(153, 153, 153);">12</li><li style="color: rgb(153, 153, 153);">13</li><li style="color: rgb(153, 153, 153);">14</li><li style="color: rgb(153, 153, 153);">15</li><li style="color: rgb(153, 153, 153);">16</li><li style="color: rgb(153, 153, 153);">17</li><li style="color: rgb(153, 153, 153);">18</li><li style="color: rgb(153, 153, 153);">19</li><li style="color: rgb(153, 153, 153);">20</li><li style="color: rgb(153, 153, 153);">21</li><li style="color: rgb(153, 153, 153);">22</li><li style="color: rgb(153, 153, 153);">23</li><li style="color: rgb(153, 153, 153);">24</li><li style="color: rgb(153, 153, 153);">25</li><li style="color: rgb(153, 153, 153);">26</li><li style="color: rgb(153, 153, 153);">27</li><li style="color: rgb(153, 153, 153);">28</li><li style="color: rgb(153, 153, 153);">29</li><li style="color: rgb(153, 153, 153);">30</li><li style="color: rgb(153, 153, 153);">31</li><li style="color: rgb(153, 153, 153);">32</li><li style="color: rgb(153, 153, 153);">33</li><li style="color: rgb(153, 153, 153);">34</li><li style="color: rgb(153, 153, 153);">35</li><li style="color: rgb(153, 153, 153);">36</li><li style="color: rgb(153, 153, 153);">37</li><li style="color: rgb(153, 153, 153);">38</li><li style="color: rgb(153, 153, 153);">39</li><li style="color: rgb(153, 153, 153);">40</li><li style="color: rgb(153, 153, 153);">41</li><li style="color: rgb(153, 153, 153);">42</li><li style="color: rgb(153, 153, 153);">43</li><li style="color: rgb(153, 153, 153);">44</li><li style="color: rgb(153, 153, 153);">45</li><li style="color: rgb(153, 153, 153);">46</li><li style="color: rgb(153, 153, 153);">47</li><li style="color: rgb(153, 153, 153);">48</li><li style="color: rgb(153, 153, 153);">49</li><li style="color: rgb(153, 153, 153);">50</li><li style="color: rgb(153, 153, 153);">51</li><li style="color: rgb(153, 153, 153);">52</li><li style="color: rgb(153, 153, 153);">53</li><li style="color: rgb(153, 153, 153);">54</li><li style="color: rgb(153, 153, 153);">55</li><li style="color: rgb(153, 153, 153);">56</li></ul></pre> 
<p>运行截图：</p> 
<p><img src="https://img-blog.csdnimg.cn/img_convert/56ddc4e8e5bba800c5ed1a156cb71b23.png" alt="image-20220924165247410"></p> 
<h1><a name="t17"></a><a id="_366"></a>进程程序替换</h1> 
<h2><a name="t18"></a><a id="or_368"></a>定义和原理（是什么or为什么）</h2> 
<h3><a name="t19"></a><a id="_370"></a>是什么</h3> 
<p>让创建出来的子进程执行全新的程序。</p> 
<h3><a name="t20"></a><a id="_374"></a>为什么</h3> 
<p>我们一般在服务器设计（Linux编程）的时候，往往需要子进程干两种事情。</p> 
<ol><li>让子进程执行父进程的代码片段（服务器代码）</li><li>让子进程执行磁盘中一个全新的程序（shell，想让客户端执行对应的程序，通过我们的进程，执行其他人写的进程代码等等）。比如c/c++调用别人写的java或者python代码程序。</li></ol> 
<p><img src="https://img-blog.csdnimg.cn/img_convert/3c497849c0e8b2eebfc5fcfdadb1380d.png" alt="image-20221001125746765"></p> 
<p>程序替换的原理：</p> 
<ol><li>将磁盘中的程序，加载入内存结构</li><li>重新建立页表映射，谁执行程序替换，就重新建立谁的页表映射（子进程）</li></ol> 
<p>效果：让父进程和子进程彻底分离，并让子进程执行一个全新的程序。</p> 
<p>注意：上面的这个过程由操作系统来完成，我们调用的是接口。</p> 
<blockquote> 
 <p>问：这个过程有没有创建新的进程？</p> 
 <p>答：没有创建新的进程，因为子进程的内核数据结构根本没变（包括子进程的PID），改变的只是页表的映射关系，仍旧是原来的进程，只是执行的是新的程序。</p> 
</blockquote> 
<h2><a name="t21"></a><a id="_396"></a>相关函数及使用（怎么办）</h2> 
<h3><a name="t22"></a><a id="_398"></a>函数总览</h3> 
<p>使用<code>man execl</code>和<code>man execve</code>指令来查看相关的函数</p> 
<p><img src="https://img-blog.csdnimg.cn/img_convert/38ac6b9362ecc57bb80c9381fb00a897.png" alt="image-20221001130727462"></p> 
<p><img src="https://img-blog.csdnimg.cn/img_convert/c807dd6646af54223cd173662d97e5b8.png" alt="image-20221001130826069"></p> 
<h3><a name="t23"></a><a id="_406"></a>具体函数使用</h3> 
<h4><a id="execl_408"></a>execl</h4> 
<pre data-index="6" class="prettyprint"><code class="has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;">int execl(const char *path, const char *arg, ...);//l可以理解成list
<div class="hljs-button {2}" data-title="复制"></div></code><ul class="pre-numbering" style=""><li style="color: rgb(153, 153, 153);">1</li></ul></pre> 
<p>path指的是路径，arg就是程序如何执行即执行方式，比如我们平时执行的<code>ls -a -l</code>，那么这个参数就是<code>"ls","-a","-l",NULL</code>这就是我们的执行方式。<mark>注意：最后一个必须是NULL，标识如何执行程序的参数传递完毕</mark>。</p> 
<p><strong>注意：path路径的写法无论是绝对路径还是相对路径都是可以的。</strong></p> 
<p>使用举例：</p> 
<p><img src="https://img-blog.csdnimg.cn/img_convert/ffcb5107c1b525a6db73c1654c79d0d8.png" alt="image-20221001134022584"></p> 
<p>运行截图：</p> 
<p><img src="https://img-blog.csdnimg.cn/img_convert/b685a7a6006d79aead5030d59bb862d6.png" alt="image-20221001134058993"></p> 
<blockquote> 
 <p>问：为什么后面的printf语句没有执行？</p> 
 <p>答：因为一旦替换成功，是将当前进程的所有代码和数据全部都替换了，而printf就是代码，替换后代码就没了，所以后面的printf语句没有执行。</p> 
 <p>问：execl这个程序替换函数是否需要判断返回值？</p> 
 <p>答：不需要。例如：<code>ret = execl(.....)</code>，程序一旦替换成功了，就不会有返回值返回到原进程中，自然也不会被接收，那么这个返回值是否还有意义呢？答案是有意义的，但是只有程序替换失败了才会有返回值返回到原进程中，才是才会被接收，并且执行<code>ret = execl(......)</code>语句 后面的代码。这个返回值最多只能得到什么原因导致的替换失败。所以不需要判断返回值，替换成功了执行替换后的代码，替换失败了执行<code>ret = execl(......)</code>代码后面的代码。</p> 
</blockquote> 
<p>用子进程来实现进程替换：</p> 
<p>代码：</p> 
<p><img src="https://img-blog.csdnimg.cn/img_convert/bc74507a200e895559fb03f4bb2acfae.png" alt="image-20221001143320051"></p> 
<p>运行截图：</p> 
<p><img src="https://img-blog.csdnimg.cn/img_convert/1464da49dc651f85dd87cc44fced70ea.png" alt="image-20221001143407117"></p> 
<p><strong>结论：子进程进行进程替换，并不会影响父进程（进程具有独立性）。</strong></p> 
<blockquote> 
 <p>问：在进程替换的时候是如何做到父进程和子进程独立的？</p> 
 <p>答：数据层面发生写时拷贝，当进行程序替换的时候，我们可以理解成为代码和数据都发生了写时拷贝，</p> 
</blockquote> 
<h4><a id="execv_450"></a>execv</h4> 
<pre data-index="7" class="prettyprint"><code class="has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;">int execv(const char *path, char *const argv[]);//v可以理解为vector
<div class="hljs-button {2}" data-title="复制"></div></code><ul class="pre-numbering" style=""><li style="color: rgb(153, 153, 153);">1</li></ul></pre> 
<p>argv是指针数组类型，数组中的元素的类型是char*。</p> 
<p><img src="https://img-blog.csdnimg.cn/img_convert/ffadbdd490cce33d15ddfff36509bb11.png" alt="image-20221001144702707"></p> 
<p>代码：</p> 
<p><img src="https://img-blog.csdnimg.cn/img_convert/01ffe7dc34f6ac010f85c8840d49e107.png" alt="image-20221001150846947"></p> 
<p>运行截图：</p> 
<p><img src="https://img-blog.csdnimg.cn/img_convert/6c08ab98f85182c9b3ef6e216abac254.png" alt="image-20221001150907833"></p> 
<h4><a id="execlp_468"></a>execlp</h4> 
<pre data-index="8" class="prettyprint"><code class="has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;">int execlp(const char *file, const char *arg, ...);//p表示的是PATH
//file:我们想要执行的程序，命名带p的，可以不带路径（注意，只有在PATH路径下的才可以，自己写的不可以），只说出执行哪一个程序即可
<div class="hljs-button {2}" data-title="复制"></div></code><ul class="pre-numbering" style=""><li style="color: rgb(153, 153, 153);">1</li><li style="color: rgb(153, 153, 153);">2</li></ul></pre> 
<p>代码：</p> 
<pre data-index="9" class="set-code-hide prettyprint"><code class="prism language-c has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;">  <span class="token number">1</span> #include<span class="token operator">&lt;</span>stdio<span class="token punctuation">.</span>h<span class="token operator">&gt;</span>  
  <span class="token number">2</span> #include<span class="token operator">&lt;</span>unistd<span class="token punctuation">.</span>h<span class="token operator">&gt;</span>  
  <span class="token number">3</span> #include<span class="token operator">&lt;</span>sys<span class="token operator">/</span>wait<span class="token punctuation">.</span>h<span class="token operator">&gt;</span>  
  <span class="token number">4</span> #include<span class="token operator">&lt;</span>stdlib<span class="token punctuation">.</span>h<span class="token operator">&gt;</span>  
  <span class="token number">5</span> <span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  
  <span class="token number">6</span> <span class="token punctuation">{<!-- --></span>  
  <span class="token number">7</span>   <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"我是一个进程，我的pid:%d\n"</span><span class="token punctuation">,</span> <span class="token function">getpid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
  <span class="token number">8</span>   <span class="token comment">//ls -a -l  </span>
  <span class="token number">9</span>   <span class="token comment">//execl("/usr/bin/ls","ls","-a", "-l", NULL);  </span>
 <span class="token number">10</span>   <span class="token comment">//printf("我是一个进程,我执行完毕了,我的pid:%d\n", getpid());  </span>
 <span class="token number">11</span>   <span class="token class-name">pid_t</span> id <span class="token operator">=</span> <span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
 <span class="token number">12</span>   <span class="token keyword">if</span><span class="token punctuation">(</span>id <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>  
 <span class="token number">13</span>   <span class="token punctuation">{<!-- --></span>  
 <span class="token number">14</span>     <span class="token comment">//子进程  </span>
 <span class="token number">15</span>     <span class="token comment">//子进程执行全新的程序  </span>
 <span class="token number">16</span>     <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"我是子进程，我的pid:%d\n"</span><span class="token punctuation">,</span> <span class="token function">getpid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
 <span class="token number">17</span>     <span class="token comment">//execl("/usr/bin/ls","ls", "-a", "-l", NULL);  </span>
 <span class="token number">18</span>     <span class="token comment">//char *const argv[] = {(char*)"ls", (char*)"-a", (char*)"-l",(char*)NULL};  </span>
 <span class="token number">19</span>     <span class="token comment">//execv("/usr/bin/ls", argv);  </span>
 <span class="token number">20</span>     <span class="token function">execlp</span><span class="token punctuation">(</span><span class="token string">"ls"</span><span class="token punctuation">,</span><span class="token string">"ls"</span><span class="token punctuation">,</span> <span class="token string">"-a"</span><span class="token punctuation">,</span> <span class="token string">"-l"</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token number">21</span>     <span class="token function">exit</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//只要exit执行了，就意味着execl程序替换失败了</span>
 <span class="token number">22</span>   <span class="token punctuation">}</span>
 <span class="token number">23</span>   <span class="token comment">//父进程</span>
 <span class="token number">24</span>   <span class="token keyword">int</span> status <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
 <span class="token number">25</span>   <span class="token keyword">int</span> ret <span class="token operator">=</span> <span class="token function">waitpid</span><span class="token punctuation">(</span>id<span class="token punctuation">,</span> <span class="token operator">&amp;</span>status<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token number">26</span>   <span class="token keyword">if</span><span class="token punctuation">(</span>ret <span class="token operator">==</span> id<span class="token punctuation">)</span>
 <span class="token number">27</span>   <span class="token punctuation">{<!-- --></span>
 <span class="token number">28</span>     <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"父进程等待成功!\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token number">29</span>     <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token number">30</span>   <span class="token punctuation">}</span>
 <span class="token number">31</span>   <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
 <span class="token number">32</span> <span class="token punctuation">}</span> 
<div class="hljs-button {2}" data-title="复制"></div></code><div class="hide-preCode-box"><span class="hide-preCode-bt" data-report-view="{&quot;spm&quot;:&quot;1001.2101.3001.7365&quot;}"><img class="look-more-preCode contentImg-no-view" src="https://csdnimg.cn/release/blogv2/dist/pc/img/newCodeMoreWhite.png" alt="" title=""></span></div><ul class="pre-numbering" style=""><li style="color: rgb(153, 153, 153);">1</li><li style="color: rgb(153, 153, 153);">2</li><li style="color: rgb(153, 153, 153);">3</li><li style="color: rgb(153, 153, 153);">4</li><li style="color: rgb(153, 153, 153);">5</li><li style="color: rgb(153, 153, 153);">6</li><li style="color: rgb(153, 153, 153);">7</li><li style="color: rgb(153, 153, 153);">8</li><li style="color: rgb(153, 153, 153);">9</li><li style="color: rgb(153, 153, 153);">10</li><li style="color: rgb(153, 153, 153);">11</li><li style="color: rgb(153, 153, 153);">12</li><li style="color: rgb(153, 153, 153);">13</li><li style="color: rgb(153, 153, 153);">14</li><li style="color: rgb(153, 153, 153);">15</li><li style="color: rgb(153, 153, 153);">16</li><li style="color: rgb(153, 153, 153);">17</li><li style="color: rgb(153, 153, 153);">18</li><li style="color: rgb(153, 153, 153);">19</li><li style="color: rgb(153, 153, 153);">20</li><li style="color: rgb(153, 153, 153);">21</li><li style="color: rgb(153, 153, 153);">22</li><li style="color: rgb(153, 153, 153);">23</li><li style="color: rgb(153, 153, 153);">24</li><li style="color: rgb(153, 153, 153);">25</li><li style="color: rgb(153, 153, 153);">26</li><li style="color: rgb(153, 153, 153);">27</li><li style="color: rgb(153, 153, 153);">28</li><li style="color: rgb(153, 153, 153);">29</li><li style="color: rgb(153, 153, 153);">30</li><li style="color: rgb(153, 153, 153);">31</li><li style="color: rgb(153, 153, 153);">32</li></ul></pre> 
<p>执行结果：</p> 
<p><img src="https://img-blog.csdnimg.cn/img_convert/6bf2d1265c37dcdbf3863eab50625c17.png" alt="image-20221001153608666"></p> 
<h4><a id="execvp_516"></a>execvp</h4> 
<pre data-index="10" class="prettyprint"><code class="prism language-c has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;"><span class="token keyword">int</span> <span class="token function">execvp</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>file<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token keyword">const</span> argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<div class="hljs-button {2}" data-title="复制"></div></code><ul class="pre-numbering" style=""><li style="color: rgb(153, 153, 153);">1</li></ul></pre> 
<p>代码练习：</p> 
<p><img src="https://img-blog.csdnimg.cn/img_convert/fde798e4f73fe52828193f686e3c8562.png" alt="image-20221001162649025"></p> 
<h4><a id="execle_526"></a>execle</h4> 
<pre data-index="11" class="prettyprint"><code class="prism language-c has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;"><span class="token keyword">int</span> <span class="token function">execle</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>path<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>arg<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">,</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token keyword">const</span> envp<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//envp就是环境变量</span>
<span class="token comment">//注意：添加环境变量给目标进程是覆盖式的，如果手动传了环境变量，原来默认的环境变量就不存在了</span>
<span class="token comment">//问：如何手动传系统自带的PATH环境变量？</span>
<span class="token comment">//答：extern char**environ;然后将environ传过去即可</span>
<div class="hljs-button {2}" data-title="复制"></div></code><ul class="pre-numbering" style=""><li style="color: rgb(153, 153, 153);">1</li><li style="color: rgb(153, 153, 153);">2</li><li style="color: rgb(153, 153, 153);">3</li><li style="color: rgb(153, 153, 153);">4</li></ul></pre> 
<p>代码练习：</p> 
<p>myexec.c文件</p> 
<pre data-index="12" class="set-code-hide prettyprint"><code class="prism language-cpp has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;">  <span class="token number">1</span> #include<span class="token operator">&lt;</span>stdio<span class="token punctuation">.</span>h<span class="token operator">&gt;</span>                                                                                         <span class="token number">2</span> #include<span class="token operator">&lt;</span>unistd<span class="token punctuation">.</span>h<span class="token operator">&gt;</span>
  <span class="token number">3</span> #include<span class="token operator">&lt;</span>sys<span class="token operator">/</span>wait<span class="token punctuation">.</span>h<span class="token operator">&gt;</span>
  <span class="token number">4</span> #include<span class="token operator">&lt;</span>stdlib<span class="token punctuation">.</span>h<span class="token operator">&gt;</span>
  <span class="token number">5</span> <span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token number">6</span> <span class="token punctuation">{<!-- --></span>
  <span class="token number">7</span>   <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"我是一个进程，我的pid:%d\n"</span><span class="token punctuation">,</span> <span class="token function">getpid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token number">8</span>   <span class="token comment">//ls -a -l</span>
  <span class="token number">9</span>   <span class="token comment">//execl("/usr/bin/ls","ls","-a", "-l", NULL);</span>
 <span class="token number">10</span>   <span class="token comment">//printf("我是一个进程,我执行完毕了,我的pid:%d\n", getpid());</span>
 <span class="token number">11</span>   pid_t id <span class="token operator">=</span> <span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token number">12</span>   <span class="token keyword">if</span><span class="token punctuation">(</span>id <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
 <span class="token number">13</span>   <span class="token punctuation">{<!-- --></span>
 <span class="token number">14</span>     <span class="token comment">//子进程</span>
 <span class="token number">15</span>     <span class="token comment">//子进程执行全新的程序</span>
 <span class="token number">16</span>     <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"我是子进程，我的pid:%d\n"</span><span class="token punctuation">,</span> <span class="token function">getpid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token number">17</span>     <span class="token keyword">char</span><span class="token operator">*</span> <span class="token keyword">const</span> _env<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token string">"MYTH=Hello, this is MYPATH!"</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
 <span class="token number">18</span>     <span class="token comment">//execl("/usr/bin/ls","ls", "-a", "-l", NULL);</span>
 <span class="token number">19</span>     <span class="token comment">//char *const argv[] = {(char*)"ls", (char*)"-a", (char*)"-l",(char*)NULL};</span>
 <span class="token number">20</span>     <span class="token comment">//execv("/usr/bin/ls", argv);</span>
 <span class="token number">21</span>     <span class="token comment">//execvp("ls",argv);</span>
 <span class="token number">22</span>     <span class="token comment">//execl("/home/ljg/linux_for_practice/2022_10_1/mycmd", "mycmd",NULL);</span>
 <span class="token number">23</span>     <span class="token function">execle</span><span class="token punctuation">(</span><span class="token string">"./mycmd"</span><span class="token punctuation">,</span> <span class="token string">"mycmd"</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span>_env<span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token number">24</span>     <span class="token function">exit</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//只要exit执行了，就意味着execl程序替换失败了</span>
 <span class="token number">25</span>   <span class="token punctuation">}</span>
 <span class="token number">26</span>   <span class="token comment">//父进程</span>
 <span class="token number">27</span>   <span class="token keyword">int</span> status <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
 <span class="token number">28</span>   <span class="token keyword">int</span> ret <span class="token operator">=</span> <span class="token function">waitpid</span><span class="token punctuation">(</span>id<span class="token punctuation">,</span> <span class="token operator">&amp;</span>status<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token number">29</span>   <span class="token keyword">if</span><span class="token punctuation">(</span>ret <span class="token operator">==</span> id<span class="token punctuation">)</span>
 <span class="token number">30</span>   <span class="token punctuation">{<!-- --></span>
 <span class="token number">31</span>     <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"父进程等待成功!\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token number">32</span>     <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                       
 <span class="token number">33</span>   <span class="token punctuation">}</span>            
 <span class="token number">34</span>   <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
 <span class="token number">35</span> <span class="token punctuation">}</span>  
<div class="hljs-button {2}" data-title="复制"></div></code><div class="hide-preCode-box"><span class="hide-preCode-bt" data-report-view="{&quot;spm&quot;:&quot;1001.2101.3001.7365&quot;}"><img class="look-more-preCode contentImg-no-view" src="https://csdnimg.cn/release/blogv2/dist/pc/img/newCodeMoreWhite.png" alt="" title=""></span></div><ul class="pre-numbering" style=""><li style="color: rgb(153, 153, 153);">1</li><li style="color: rgb(153, 153, 153);">2</li><li style="color: rgb(153, 153, 153);">3</li><li style="color: rgb(153, 153, 153);">4</li><li style="color: rgb(153, 153, 153);">5</li><li style="color: rgb(153, 153, 153);">6</li><li style="color: rgb(153, 153, 153);">7</li><li style="color: rgb(153, 153, 153);">8</li><li style="color: rgb(153, 153, 153);">9</li><li style="color: rgb(153, 153, 153);">10</li><li style="color: rgb(153, 153, 153);">11</li><li style="color: rgb(153, 153, 153);">12</li><li style="color: rgb(153, 153, 153);">13</li><li style="color: rgb(153, 153, 153);">14</li><li style="color: rgb(153, 153, 153);">15</li><li style="color: rgb(153, 153, 153);">16</li><li style="color: rgb(153, 153, 153);">17</li><li style="color: rgb(153, 153, 153);">18</li><li style="color: rgb(153, 153, 153);">19</li><li style="color: rgb(153, 153, 153);">20</li><li style="color: rgb(153, 153, 153);">21</li><li style="color: rgb(153, 153, 153);">22</li><li style="color: rgb(153, 153, 153);">23</li><li style="color: rgb(153, 153, 153);">24</li><li style="color: rgb(153, 153, 153);">25</li><li style="color: rgb(153, 153, 153);">26</li><li style="color: rgb(153, 153, 153);">27</li><li style="color: rgb(153, 153, 153);">28</li><li style="color: rgb(153, 153, 153);">29</li><li style="color: rgb(153, 153, 153);">30</li><li style="color: rgb(153, 153, 153);">31</li><li style="color: rgb(153, 153, 153);">32</li><li style="color: rgb(153, 153, 153);">33</li><li style="color: rgb(153, 153, 153);">34</li></ul></pre> 
<p>makefile文件：</p> 
<p><img src="https://img-blog.csdnimg.cn/img_convert/5d5ef3674467c79a1e97e57e6fea65f9.png" alt="image-20221001190523672"></p> 
<p>mycmd.cpp文件：</p> 
<pre data-index="13" class="prettyprint"><code class="prism language-cpp has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;">  <span class="token number">1</span> #include<span class="token operator">&lt;</span>iostream<span class="token operator">&gt;</span>
  <span class="token number">2</span> #include<span class="token operator">&lt;</span>stdlib<span class="token punctuation">.</span>h<span class="token operator">&gt;</span>
  <span class="token number">3</span> <span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>
  <span class="token number">4</span> <span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token number">5</span> <span class="token punctuation">{<!-- --></span>
  <span class="token number">6</span>   cout <span class="token operator">&lt;&lt;</span> <span class="token string">"MYTH="</span> <span class="token operator">&lt;&lt;</span> <span class="token function">getenv</span><span class="token punctuation">(</span><span class="token string">"MYTH"</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>                                                               <span class="token number">7</span>   cout <span class="token operator">&lt;&lt;</span> <span class="token string">"hello world"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
  <span class="token number">8</span>   cout <span class="token operator">&lt;&lt;</span> <span class="token string">"hello world"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
  <span class="token number">9</span> 
 <span class="token number">10</span>   <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
 <span class="token number">11</span> <span class="token punctuation">}</span>
<div class="hljs-button {2}" data-title="复制"></div></code><ul class="pre-numbering" style=""><li style="color: rgb(153, 153, 153);">1</li><li style="color: rgb(153, 153, 153);">2</li><li style="color: rgb(153, 153, 153);">3</li><li style="color: rgb(153, 153, 153);">4</li><li style="color: rgb(153, 153, 153);">5</li><li style="color: rgb(153, 153, 153);">6</li><li style="color: rgb(153, 153, 153);">7</li><li style="color: rgb(153, 153, 153);">8</li><li style="color: rgb(153, 153, 153);">9</li><li style="color: rgb(153, 153, 153);">10</li></ul></pre> 
<p>运行截图：</p> 
<p><img src="https://img-blog.csdnimg.cn/img_convert/d75afaaea029752d5e8c8b81e7851147.png" alt="image-20221001195818505"></p> 
<h4><a id="execve_599"></a>execve</h4> 
<pre data-index="14" class="prettyprint"><code class="prism language-c has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;"> <span class="token keyword">int</span> <span class="token function">execve</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>path<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token keyword">const</span> argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token keyword">const</span> envp<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<div class="hljs-button {2}" data-title="复制"></div></code><ul class="pre-numbering" style=""><li style="color: rgb(153, 153, 153);">1</li></ul></pre> 
<h4><a id="execvpe_605"></a>execvpe</h4> 
<pre data-index="15" class="prettyprint"><code class="prism language-cpp has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;"><span class="token keyword">int</span> <span class="token function">execvpe</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>file<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token keyword">const</span> argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token keyword">const</span> envp<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<div class="hljs-button {2}" data-title="复制"></div></code><ul class="pre-numbering" style=""><li style="color: rgb(153, 153, 153);">1</li></ul></pre> 
<h4><a id="_611"></a>总结</h4> 
<blockquote> 
 <p>问：为什么要有这么多接口？</p> 
 <p>答：是为了适配更多的应用场景。</p> 
 <p>问：为什么execve是单独的？</p> 
 <p>答：execve位于2号手册，是单独的系统调用，其它的严格意义上来讲并不是真正的系统接口，是基于execve系统接口之上进行的封装。</p> 
</blockquote> 
<blockquote> 
 <p>问：各种字母代表的是什么意思？</p> 
 <p>答：l(list)：表示参数使用列表 v(vector)：参数用数组 p(path)：有p自动搜索环境变量PATH e(env)：表示自己维护环境变量</p> 
</blockquote> 
<div class="table-box"><table><thead><tr><th>函数名</th><th>参数格式</th><th>是否带路径</th><th>是否使用当前环境变量</th></tr></thead><tbody><tr><td>execl</td><td>列表</td><td>不是</td><td>是</td></tr><tr><td>execlp</td><td>列表</td><td>是</td><td>是</td></tr><tr><td>execle</td><td>列表</td><td>不是</td><td>不是，需要自己组装环境变量</td></tr><tr><td>execv</td><td>数组</td><td>不是</td><td>是</td></tr><tr><td>execvp</td><td>数组</td><td>是</td><td>是</td></tr><tr><td>execve</td><td>数组</td><td>不是</td><td>不是，需要自己组装环境变量</td></tr></tbody></table></div>
<h1><a name="t24"></a><a id="Shell_634"></a>简易Shell</h1> 
<pre data-index="16" class="set-code-hide prettyprint"><code class="prism language-c has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;">    <span class="token number">1</span> #include<span class="token operator">&lt;</span>stdio<span class="token punctuation">.</span>h<span class="token operator">&gt;</span>                                                                                                                                      
    <span class="token number">2</span> #include<span class="token operator">&lt;</span>stdlib<span class="token punctuation">.</span>h<span class="token operator">&gt;</span>
    <span class="token number">3</span> #include<span class="token operator">&lt;</span>string<span class="token punctuation">.</span>h<span class="token operator">&gt;</span>
    <span class="token number">4</span> #include<span class="token operator">&lt;</span>unistd<span class="token punctuation">.</span>h<span class="token operator">&gt;</span>
    <span class="token number">5</span> #include<span class="token operator">&lt;</span>sys<span class="token operator">/</span>wait<span class="token punctuation">.</span>h<span class="token operator">&gt;</span>
    <span class="token number">6</span> #include<span class="token operator">&lt;</span>sys<span class="token operator">/</span>types<span class="token punctuation">.</span>h<span class="token operator">&gt;</span>
    <span class="token number">7</span> #define NUM <span class="token number">1024</span>
    <span class="token number">8</span> #define SIZE <span class="token number">128</span>
    <span class="token number">9</span> #define SEP <span class="token string">" "</span>
   <span class="token number">10</span> <span class="token keyword">char</span> command_line<span class="token punctuation">[</span>NUM<span class="token punctuation">]</span><span class="token punctuation">;</span>
   <span class="token number">11</span> <span class="token keyword">char</span><span class="token operator">*</span> command_args<span class="token punctuation">[</span>SIZE<span class="token punctuation">]</span><span class="token punctuation">;</span>
   <span class="token number">12</span> <span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
   <span class="token number">13</span> <span class="token punctuation">{<!-- --></span>
   <span class="token number">14</span>   <span class="token comment">//shell本质上就是一个死循环</span>
   <span class="token number">15</span>   <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
   <span class="token number">16</span>   <span class="token punctuation">{<!-- --></span>
   <span class="token number">17</span>     <span class="token comment">//不关心获取这些属性的接口</span>
   <span class="token number">18</span>     <span class="token comment">//1.显示提示符</span>
   <span class="token number">19</span>     <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"[zs@VM-0-3-centos 当前目录]# "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token number">20</span>     <span class="token function">fflush</span><span class="token punctuation">(</span><span class="token constant">stdout</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token number">21</span>     <span class="token comment">//2.获取用户输入 </span>
   <span class="token number">22</span>     <span class="token function">memset</span><span class="token punctuation">(</span>command_line<span class="token punctuation">,</span><span class="token char">'\0'</span><span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>command_line<span class="token punctuation">)</span><span class="token operator">*</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token number">23</span>     <span class="token function">fgets</span><span class="token punctuation">(</span>command_line<span class="token punctuation">,</span> NUM<span class="token punctuation">,</span> <span class="token constant">stdin</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//从标准输入中获取的，获取到的是C风格的字符串</span>
   <span class="token number">24</span>     command_line<span class="token punctuation">[</span><span class="token function">strlen</span><span class="token punctuation">(</span>command_line<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token char">'\0'</span><span class="token punctuation">;</span> 
   <span class="token number">25</span>     <span class="token comment">//3.分割字符串 "ls -a -l" "ls" "-a" "-l"</span>
   <span class="token number">26</span>     command_args<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">strtok</span><span class="token punctuation">(</span>command_line<span class="token punctuation">,</span> SEP<span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token number">27</span>     <span class="token keyword">int</span> index <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
   <span class="token number">28</span>     <span class="token keyword">while</span><span class="token punctuation">(</span>command_args<span class="token punctuation">[</span>index<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">strtok</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token constant">NULL</span><span class="token punctuation">,</span> SEP<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token number">29</span>     <span class="token comment">//5.创建进程,执行</span>
   <span class="token number">30</span>     <span class="token class-name">pid_t</span> id <span class="token operator">=</span> <span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   
   <span class="token number">31</span>     <span class="token keyword">if</span><span class="token punctuation">(</span>id <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
   <span class="token number">32</span>     <span class="token punctuation">{<!-- --></span>
   <span class="token number">33</span>       <span class="token comment">//child</span>
   <span class="token number">34</span>       <span class="token function">execvp</span><span class="token punctuation">(</span>command_args<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> command_args<span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token number">35</span>       <span class="token function">exit</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//执行到这里，子进程一定替换失败了</span>
   <span class="token number">36</span>     <span class="token punctuation">}</span>
   <span class="token number">37</span>     <span class="token keyword">int</span> status <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
   <span class="token number">38</span>     <span class="token class-name">pid_t</span> ret <span class="token operator">=</span> <span class="token function">waitpid</span><span class="token punctuation">(</span>id<span class="token punctuation">,</span> <span class="token operator">&amp;</span>status<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token number">39</span>     <span class="token keyword">if</span><span class="token punctuation">(</span>ret<span class="token operator">&gt;</span><span class="token number">0</span><span class="token punctuation">)</span>
   <span class="token number">40</span>     <span class="token punctuation">{<!-- --></span>
   <span class="token number">41</span>      <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"等待子进程成功:sig:%d,code:%d\n"</span><span class="token punctuation">,</span> status<span class="token operator">&amp;</span><span class="token number">0x7F</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>status<span class="token operator">&gt;&gt;</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token operator">&amp;</span><span class="token number">0xFF</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
   <span class="token number">42</span>     <span class="token punctuation">}</span>
   <span class="token number">43</span>   <span class="token punctuation">}</span><span class="token comment">//end while</span>
   <span class="token number">44</span> 
   <span class="token number">45</span> 
   <span class="token number">46</span>   <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
   <span class="token number">47</span> <span class="token punctuation">}</span> 
<div class="hljs-button {2}" data-title="复制"></div></code><div class="hide-preCode-box"><span class="hide-preCode-bt" data-report-view="{&quot;spm&quot;:&quot;1001.2101.3001.7365&quot;}"><img class="look-more-preCode contentImg-no-view" src="https://csdnimg.cn/release/blogv2/dist/pc/img/newCodeMoreWhite.png" alt="" title=""></span></div><ul class="pre-numbering" style=""><li style="color: rgb(153, 153, 153);">1</li><li style="color: rgb(153, 153, 153);">2</li><li style="color: rgb(153, 153, 153);">3</li><li style="color: rgb(153, 153, 153);">4</li><li style="color: rgb(153, 153, 153);">5</li><li style="color: rgb(153, 153, 153);">6</li><li style="color: rgb(153, 153, 153);">7</li><li style="color: rgb(153, 153, 153);">8</li><li style="color: rgb(153, 153, 153);">9</li><li style="color: rgb(153, 153, 153);">10</li><li style="color: rgb(153, 153, 153);">11</li><li style="color: rgb(153, 153, 153);">12</li><li style="color: rgb(153, 153, 153);">13</li><li style="color: rgb(153, 153, 153);">14</li><li style="color: rgb(153, 153, 153);">15</li><li style="color: rgb(153, 153, 153);">16</li><li style="color: rgb(153, 153, 153);">17</li><li style="color: rgb(153, 153, 153);">18</li><li style="color: rgb(153, 153, 153);">19</li><li style="color: rgb(153, 153, 153);">20</li><li style="color: rgb(153, 153, 153);">21</li><li style="color: rgb(153, 153, 153);">22</li><li style="color: rgb(153, 153, 153);">23</li><li style="color: rgb(153, 153, 153);">24</li><li style="color: rgb(153, 153, 153);">25</li><li style="color: rgb(153, 153, 153);">26</li><li style="color: rgb(153, 153, 153);">27</li><li style="color: rgb(153, 153, 153);">28</li><li style="color: rgb(153, 153, 153);">29</li><li style="color: rgb(153, 153, 153);">30</li><li style="color: rgb(153, 153, 153);">31</li><li style="color: rgb(153, 153, 153);">32</li><li style="color: rgb(153, 153, 153);">33</li><li style="color: rgb(153, 153, 153);">34</li><li style="color: rgb(153, 153, 153);">35</li><li style="color: rgb(153, 153, 153);">36</li><li style="color: rgb(153, 153, 153);">37</li><li style="color: rgb(153, 153, 153);">38</li><li style="color: rgb(153, 153, 153);">39</li><li style="color: rgb(153, 153, 153);">40</li><li style="color: rgb(153, 153, 153);">41</li><li style="color: rgb(153, 153, 153);">42</li><li style="color: rgb(153, 153, 153);">43</li><li style="color: rgb(153, 153, 153);">44</li><li style="color: rgb(153, 153, 153);">45</li><li style="color: rgb(153, 153, 153);">46</li><li style="color: rgb(153, 153, 153);">47</li></ul></pre>
                </div><div data-report-view="{&quot;mod&quot;:&quot;1585297308_001&quot;,&quot;spm&quot;:&quot;1001.2101.3001.6548&quot;,&quot;dest&quot;:&quot;https://blog.csdn.net/m0_57304511/article/details/127302447&quot;,&quot;extend1&quot;:&quot;pc&quot;,&quot;ab&quot;:&quot;new&quot;}"><div></div></div>
                <link href="https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/markdown_views-22a2fefd3b.css" rel="stylesheet">
                <link href="https://csdnimg.cn/release/blogv2/dist/mdeditor/css/style-4f8fbf9108.css" rel="stylesheet">
        </div>